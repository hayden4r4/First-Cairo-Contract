import { StarknetWrapper } from "./starknet-wrappers";
/**
 * According to: https://starknet.io/docs/hello_starknet/intro.html#interact-with-the-contract
 * Not using an enum to avoid code duplication and reverse mapping.
 */
export declare type TxStatus = 
/** The transaction passed the validation and entered the pending block. */
"PENDING"
/** The transaction has not been received yet (i.e., not written to storage). */
 | "NOT_RECEIVED"
/** The transaction was received by the operator. */
 | "RECEIVED"
/** The transaction failed validation and thus was skipped. */
 | "REJECTED"
/** The transaction passed the validation and entered an actual created block. */
 | "ACCEPTED_ON_L2"
/** The transaction was accepted on-chain. */
 | "ACCEPTED_ON_L1";
export declare type StarknetContractFactoryConfig = StarknetContractConfig & {
    metadataPath: string;
};
export interface StarknetContractConfig {
    starknetWrapper: StarknetWrapper;
    abiPath: string;
    gatewayUrl: string;
    feederGatewayUrl: string;
}
export declare type Numeric = number | bigint;
/**
 * Object whose keys are strings (names) and values are any object.
 */
export interface StringMap {
    [key: string]: any;
}
export declare type Choice = "call" | "invoke";
export declare function extractTxHash(response: string): string;
/**
 * The object returned by starknet tx_status.
 */
declare type StatusObject = {
    block_hash: string;
    tx_status: TxStatus;
};
export declare function isTxAccepted(statusObject: StatusObject): boolean;
export declare function iterativelyCheckStatus(txHash: string, starknetWrapper: StarknetWrapper, gatewayUrl: string, feederGatewayUrl: string, resolve: (status: string) => void, reject: (reason?: any) => void): Promise<void>;
export declare class StarknetContractFactory {
    private starknetWrapper;
    private abi;
    private abiPath;
    private constructorAbi;
    private metadataPath;
    private gatewayUrl;
    private feederGatewayUrl;
    constructor(config: StarknetContractFactoryConfig);
    /**
     * Deploy a contract instance to a new address.
     * Optionally pass constructor arguments.
     *
     * E.g. if there is a function
     * ```text
     * @constructor
     * func constructor{
     *     syscall_ptr : felt*,
     *     pedersen_ptr : HashBuiltin*,
     *     range_check_ptr
     * } (initial_balance : felt):
     *     balance.write(initial_balance)
     *     return ()
     * end
     * ```
     * this plugin allows you to call it like:
     * ```
     * const contractFactory = ...;
     * const instance = await contractFactory.deploy({ initial_balance: 100 });
     * ```
     * @param constructorArguments constructor arguments
     * @returns the newly created instance
     */
    deploy(constructorArguments?: StringMap, signature?: Array<Numeric>): Promise<StarknetContract>;
    private handleConstructorArguments;
    /**
     * Returns a contract instance with set address.
     * No address validity checks are performed.
     * @param address the address of a previously deployed contract
     * @returns the contract instance at the provided address
     */
    getContractAt(address: string): StarknetContract;
}
export declare class StarknetContract {
    private starknetWrapper;
    private abi;
    private abiPath;
    address: string;
    private gatewayUrl;
    private feederGatewayUrl;
    constructor(config: StarknetContractConfig);
    private invokeOrCall;
    /**
     * Invoke the function by name and optionally provide arguments in an array.
     * For a usage example @see {@link call}
     * @param functionName
     * @param args
     * @param signature array of transaction signature elements
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    invoke(functionName: string, args?: StringMap, signature?: Array<Numeric>): Promise<void>;
    /**
     * Call the function by name and optionally provide arguments in an array.
     *
     * E.g. If your contract has a function
     * ```text
     * func double_sum(x: felt, y: felt) -> (res: felt):
     *     return (res=(x + y) * 2)
     * end
     * ```
     * then you would call it like:
     * ```typescript
     * const contract = ...;
     * const { res: sum } = await contract.call("double_sum", { x: 2, y: 3 });
     * console.log(sum);
     * ```
     * which would result in:
     * ```text
     * > 10n
     * ```
     * @param functionName
     * @param args
     * @param signature array of transaction signature elements
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    call(functionName: string, args?: StringMap, signature?: Array<Numeric>): Promise<StringMap>;
}
export {};
