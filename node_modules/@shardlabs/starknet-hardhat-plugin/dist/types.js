"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetContract = exports.StarknetContractFactory = exports.iterativelyCheckStatus = exports.isTxAccepted = exports.extractTxHash = void 0;
const fs = __importStar(require("fs"));
const plugins_1 = require("hardhat/plugins");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const adapt_1 = require("./adapt");
function extractFromResponse(response, regex) {
    const matched = response.match(regex);
    if (!matched || !matched[1]) {
        throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Could not parse response. Check that you're using the correct network.");
    }
    return matched[1];
}
function extractTxHash(response) {
    return extractFromResponse(response, /^Transaction hash: (.*)$/m);
}
exports.extractTxHash = extractTxHash;
function extractAddress(response) {
    return extractFromResponse(response, /^Contract address: (.*)$/m);
}
function checkStatus(hash, starknetWrapper, gatewayUrl, feederGatewayUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        const executed = yield starknetWrapper.getTxStatus({
            hash,
            gatewayUrl,
            feederGatewayUrl
        });
        if (executed.statusCode) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, executed.stderr.toString());
        }
        const response = executed.stdout.toString();
        try {
            const responseParsed = JSON.parse(response);
            return responseParsed;
        }
        catch (err) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, `Cannot interpret the following: ${response}`);
        }
    });
}
const ACCEPTABLE_STATUSES = ["ACCEPTED_ON_L2", "ACCEPTED_ON_L1"];
function isTxAccepted(statusObject) {
    return ACCEPTABLE_STATUSES.includes(statusObject.tx_status);
}
exports.isTxAccepted = isTxAccepted;
const UNACCEPTABLE_STATUSES = ["REJECTED"];
function isTxRejected(statusObject) {
    return UNACCEPTABLE_STATUSES.includes(statusObject.tx_status);
}
function iterativelyCheckStatus(txHash, starknetWrapper, gatewayUrl, feederGatewayUrl, resolve, reject) {
    return __awaiter(this, arguments, void 0, function* () {
        const statusObject = yield checkStatus(txHash, starknetWrapper, gatewayUrl, feederGatewayUrl);
        if (isTxAccepted(statusObject)) {
            resolve(statusObject.tx_status);
        }
        else if (isTxRejected(statusObject)) {
            reject(new Error("Transaction rejected."));
        }
        else {
            // Make a recursive call, but with a delay.
            // Local var `arguments` holds what was passed in the current call
            const timeout = constants_1.CHECK_STATUS_TIMEOUT; // ms
            setTimeout(iterativelyCheckStatus, timeout, ...arguments);
        }
    });
}
exports.iterativelyCheckStatus = iterativelyCheckStatus;
/**
 * Reads ABI from `abiPath` and converts it to an object for lookup by name.
 * @param abiPath the path where ABI is stored on disk
 * @returns an object mapping ABI entry names with their values
 */
function readAbi(abiPath) {
    const abiRaw = fs.readFileSync(abiPath).toString();
    const abiArray = JSON.parse(abiRaw);
    const abi = {};
    for (const abiEntry of abiArray) {
        if (!abiEntry.name) {
            const msg = `Abi entry has no name: ${abiEntry}`;
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
        }
        abi[abiEntry.name] = abiEntry;
    }
    return abi;
}
/**
 * Add `signature` elements to to `starknetArgs`, if there are any.
 * @param signature array of transaction signature elements
 * @param starknetArgs destination array
 */
function handleSignature(signature) {
    if (signature) {
        return signature.map(s => s.toString());
    }
    return [];
}
class StarknetContractFactory {
    constructor(config) {
        this.starknetWrapper = config.starknetWrapper;
        this.abiPath = config.abiPath;
        this.abi = readAbi(this.abiPath);
        this.gatewayUrl = config.gatewayUrl;
        this.feederGatewayUrl = config.feederGatewayUrl;
        this.metadataPath = config.metadataPath;
        // find constructor
        for (const abiEntryName in this.abi) {
            const abiEntry = this.abi[abiEntryName];
            if (abiEntry.type === "constructor") {
                this.constructorAbi = abiEntry;
            }
        }
    }
    /**
     * Deploy a contract instance to a new address.
     * Optionally pass constructor arguments.
     *
     * E.g. if there is a function
     * ```text
     * @constructor
     * func constructor{
     *     syscall_ptr : felt*,
     *     pedersen_ptr : HashBuiltin*,
     *     range_check_ptr
     * } (initial_balance : felt):
     *     balance.write(initial_balance)
     *     return ()
     * end
     * ```
     * this plugin allows you to call it like:
     * ```
     * const contractFactory = ...;
     * const instance = await contractFactory.deploy({ initial_balance: 100 });
     * ```
     * @param constructorArguments constructor arguments
     * @returns the newly created instance
     */
    deploy(constructorArguments, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const executed = yield this.starknetWrapper.deploy({
                contract: this.metadataPath,
                inputs: this.handleConstructorArguments(constructorArguments),
                signature: handleSignature(signature),
                gatewayUrl: this.gatewayUrl,
            });
            if (executed.statusCode) {
                const msg = "Could not deploy contract. Check the network url in config. Is it responsive?";
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
            }
            const executedOutput = executed.stdout.toString();
            const address = extractAddress(executedOutput);
            const txHash = extractTxHash(executedOutput);
            const contract = new StarknetContract({
                abiPath: this.abiPath,
                starknetWrapper: this.starknetWrapper,
                feederGatewayUrl: this.feederGatewayUrl,
                gatewayUrl: this.gatewayUrl
            });
            contract.address = address;
            return new Promise((resolve, reject) => {
                iterativelyCheckStatus(txHash, this.starknetWrapper, this.gatewayUrl, this.feederGatewayUrl, () => resolve(contract), reject);
            });
        });
    }
    handleConstructorArguments(constructorArguments) {
        if (this.constructorAbi) {
            if (!constructorArguments || Object.keys(constructorArguments).length === 0) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Constructor arguments required but not provided.");
            }
            const argumentArray = (0, adapt_1.adaptInput)(this.constructorAbi.name, constructorArguments, this.constructorAbi.inputs, this.abi);
            return argumentArray;
        }
        if (constructorArguments && Object.keys(constructorArguments).length) {
            if (!this.constructorAbi) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Constructor arguments provided but not required.");
            }
            // other case already handled
        }
        return [];
    }
    /**
     * Returns a contract instance with set address.
     * No address validity checks are performed.
     * @param address the address of a previously deployed contract
     * @returns the contract instance at the provided address
     */
    getContractAt(address) {
        if (!address) {
            throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "No address provided");
        }
        const contract = new StarknetContract({
            abiPath: this.abiPath,
            starknetWrapper: this.starknetWrapper,
            feederGatewayUrl: this.feederGatewayUrl,
            gatewayUrl: this.gatewayUrl
        });
        contract.address = address;
        return contract;
    }
}
exports.StarknetContractFactory = StarknetContractFactory;
class StarknetContract {
    constructor(config) {
        this.starknetWrapper = config.starknetWrapper;
        this.abiPath = config.abiPath;
        this.abi = readAbi(this.abiPath);
        this.gatewayUrl = config.gatewayUrl;
        this.feederGatewayUrl = config.feederGatewayUrl;
    }
    invokeOrCall(choice, functionName, args, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.address) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Contract not deployed");
            }
            const func = this.abi[functionName];
            if (!func) {
                const msg = `Function '${functionName}' doesn't exist on this contract.`;
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, msg);
            }
            if (Array.isArray(args)) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, "Arguments should be passed in the form of an object.");
            }
            const executed = yield this.starknetWrapper.invokeOrCall({
                choice,
                address: this.address,
                abi: this.abiPath,
                functionName: functionName,
                inputs: (0, adapt_1.adaptInput)(functionName, args, func.inputs, this.abi),
                signature: handleSignature(signature),
                gatewayUrl: this.gatewayUrl,
                feederGatewayUrl: this.feederGatewayUrl
            });
            if (executed.statusCode) {
                const msg = `Could not ${choice} ${functionName}:\n` + executed.stderr.toString();
                const replacedMsg = (0, utils_1.adaptLog)(msg);
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, replacedMsg);
            }
            return executed;
        });
    }
    /**
     * Invoke the function by name and optionally provide arguments in an array.
     * For a usage example @see {@link call}
     * @param functionName
     * @param args
     * @param signature array of transaction signature elements
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    invoke(functionName, args, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const executed = yield this.invokeOrCall("invoke", functionName, args, signature);
            const txHash = extractTxHash(executed.stdout.toString());
            return new Promise((resolve, reject) => {
                iterativelyCheckStatus(txHash, this.starknetWrapper, this.gatewayUrl, this.feederGatewayUrl, status => resolve(), reject);
            });
        });
    }
    /**
     * Call the function by name and optionally provide arguments in an array.
     *
     * E.g. If your contract has a function
     * ```text
     * func double_sum(x: felt, y: felt) -> (res: felt):
     *     return (res=(x + y) * 2)
     * end
     * ```
     * then you would call it like:
     * ```typescript
     * const contract = ...;
     * const { res: sum } = await contract.call("double_sum", { x: 2, y: 3 });
     * console.log(sum);
     * ```
     * which would result in:
     * ```text
     * > 10n
     * ```
     * @param functionName
     * @param args
     * @param signature array of transaction signature elements
     * @returns a Promise that resolves when the status of the transaction is at least `PENDING`
     */
    call(functionName, args, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const executed = yield this.invokeOrCall("call", functionName, args, signature);
            const func = this.abi[functionName];
            const adaptedOutput = (0, adapt_1.adaptOutput)(executed.stdout.toString(), func.outputs, this.abi);
            return adaptedOutput;
        });
    }
}
exports.StarknetContract = StarknetContract;
//# sourceMappingURL=types.js.map